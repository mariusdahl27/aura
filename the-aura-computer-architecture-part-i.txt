The AVRA Computer Architecture

Version 1.0


Part I: Architectural Concepts




Document Version: DRAFT 2020-12-12




Marius Dahl








Copyright 2020 Marius Dahl.

This document is released under the Creative Commons Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0).

A copy of the license can be found at:

https://creativecommons.org/licenses/by-sa/4.0/


Marius Dahl:

mariusdahl27@protonmail.com








The AVRA Computer Architecture:

• Part I: Architectural Concepts
• Part II: Instruction Descriptions
• Part III: Instruction Encoding Tables


The latest version of this document can be found at:

https://github.com/mariusdahl27/aura








────────
Contents
────────


 1  Introduction
 2  Architectural Scope
 3  Versioning and Compatibility
      3.1  Aura Version Identifiers
 4  Aura Computer Systems
 5  Units of Data
 6  Processors
      6.1  Privilege Levels
      6.2  Exceptions
      6.3  Interrupts
      6.4  Data Formats
      6.5  Architectural State
      6.6  Instructions
      6.7  Vector Processing
 7  Primary Memory
      7.1  Addressing Characteristics
             7.1.1  The Word Addressing Scheme
             7.1.2  The Octet Addressing Scheme
             7.1.3  Instruction Package Addressing
      7.2  Support for Smaller Address Spaces
      7.3  Read and Write Side Effects
      7.4  Backed and Unbacked Locations
      7.5  Initial Value of Primary Memory Contents
 8  Agents
 9  The Aura Memory Consistency Model
      9.1  Characteristics
      9.2  Instructions Requiring Special Consideration
10  Architecture Extensions
      10.1  Identification Mechanisms
      10.2  Instruction Encoding Issues
      10.3  Promotion of Architecture Extensions
11  Derivative Computer Architectures
12  Miscellaneous Topics








───────────────
1  Introduction
───────────────


Aura is an experimental computer architecture for exploring 128-bit computing.

Aura is an open architecture. A license does not have to be obtained in order to design architecture extensions and implementations. Architecture extensions and implementations may be open or proprietary.








──────────────────────
2  Architectural Scope
──────────────────────


Aura has a minimal scope to maximize implementation freedom. It defines a base architecture that is missing most of the privileged architecture necessary for realizing a functioning computer system. The missing features must be provided by implementation-specific or standard architecture extensions in order to realize a functioning implementation. There are a small number of restrictions on the design of these extensions, in order to ensure that an implementation's privileged architecture can support the features in the base architecture.








───────────────────────────────
3  Versioning and Compatibility
───────────────────────────────


Aura is expected to evolve over time, resulting in a series of successive versions. Later versions may be incompatible with earlier versions. This allows Aura to evolve freely, without earlier versions restricting the design of later versions, and to avoid the complexity and cost that arises when compatibility must be maintained between many versions, dissimilar versions, or a combination of the two.

The versioning convention used by Aura is a two-part version number composed of major and minor version numbers separated by a period. New versions that have significant consequences for compatibility increment the major version number; those that have little or no consequence for compatibility increment the minor version number. The first version is 1.0 (the major version number cannot be zero).

The document, "The Aura Computer Architecture", uses an ISO 8601 date as the document version. The stated date is the date on which the document version was completed. Changes to the document that do not pertain to architectural flaws or change architectural intent are editorial, not architectural, issues. Thus, these changes are reflected in the document version, not the architecture version.

Document versions that are prefixed with the term "DRAFT" are descriptions of the architecture while it is in a state of development, and thus, flux. In DRAFT versions of the document, changes that pertain to architectural flaws or architectural intent affect the document version, not the architecture version.




─────────────────────────────
3.1  Aura Version Identifiers
─────────────────────────────


Aura has an architectural mechanism, Aura Version Identifiers (AVIs), that enables software to identify which version of Aura is implemented by any given processor (see Section 6, Processors). AVIs are 64-bit unsigned integers that are permanently assigned to an Aura version. Aura provides an instruction that obtains the AVI of a processor. While different versions of Aura may have implications for agents (see Section 8, Agents), AVIs are not available for agents, as they are either hardware-based state machines or implementations of agent-specific architectures.

AVIs are assigned in sequential order, starting from AVI 1. AVI 0 is reserved for public internal use by versions of the architecture that do not need to be identifiable to software. Reasons for creating such versions include development or experimentation. Unassigned AVIs are reserved for future use.

As of this document version, the following AVIs have been assigned:

• AVI 0: Reserved
• AVI 1: Aura Version 1.0








────────────────────────
4  Aura Computer Systems
────────────────────────


Aura is a computer architecture for a binary, general-purpose, stored-program computer. An Aura computer system consists of one or more processors, the primary memory, and one or more agents. The architecture directly supports the multiple instruction, multiple data (MIMD) multiprocessing paradigm via the shared primary memory and Aura Memory Consistency Model.








────────────────
5  Units of Data
────────────────


Aura defines five units of data that pertain the size of a datum in bits:

• The octet (OT), consisting of 8 continuous bits, 0—7.
• The bi-octet (BO), consisting of 16 continuous bits, 0—15.
• The quadrant-word (QW), consisting of 32 continuous bits, 0—31.
• The semi-word (SW), consisting of 64 continuous bits, 0—63.
• The word (WD), consisting of 128 continuous bits, 0—127.

The bits in a unit of data are numbered starting from zero. The first bit is the leftmost bit.

From the bi-octet onward, each unit of data can contain a multiple of one or more smaller units of data. These smaller units of data are laid out within a larger unit of data in little-endian order as follows:

┌────────────────┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
│         Octet: │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│
│                ├──┴──┼──┴──┼──┴──┼──┴──┼──┴──┼──┴──┼──┴──┼──┴──┤
│      Bi-octet: │    7│    6│    5│    4│    3│    2│    1│    0│
│                ├─────┴─────┼─────┴─────┼─────┴─────┼─────┴─────┤
│ Quadrant-word: │          3│          2│          1│          0│
│                ├───────────┴───────────┼───────────┴───────────┤
│     Semi-word: │                      1│                      0│
│                ├───────────────────────┴───────────────────────┤
│          Word: │                                              0│
└────────────────┴───────────────────────────────────────────────┘








─────────────
6  Processors
─────────────


A processor is an abstract entity that has its own instruction and data streams. Each processor operates independently and concurrently with all other processors and agents in an Aura computer system. In the Aura computer architecture, the concept of a processor is unrelated to any physical entity that may be called a processor other contexts.

The processors in an Aura computer system may implement different versions of the architecture if they are mutually compatible. Additionally, all of the implemented architecture extensions must be mutually compatible.

When an Aura computer system is started, each processor begins performing the stored-program computer instruction cycle. This instruction cycle is repeats until the Aura computer system is stopped.

A processor's instruction stream is not guaranteed to be coherent with the primary memory. If a processor implementation does not provide coherence between its instruction stream and the primary memory, it is required to provide a privileged mechanism for enforcing coherence via an architecture extension.

Processors must implement an architecture extension that provides a privileged mechanism for interrupting other processors and agents. The privilege level of this mechanism must be the highest privilege level supported by the processor.

Processors address other processors using a 128-bit processor address. A subset of the 128-bit processor address space may be supported by limiting the size of the processor address to N bits, where 0 < N < 128.

Processors address agents using a 128-bit address. A subset of the 128-bit agent address space may be supported by limiting the size of the agent address to N bits, where 0 < N < 128.




─────────────────────
6.1  Privilege Levels
─────────────────────


The base architecture provides a framework for security via privilege levels. All instructions have a privilege level, which expresses the operating privilege level required to execute the instructions. Because architectural state is accessed by instructions, and the exception and interrupt mechanisms build upon the privilege level framework, these also privilege levels.

Every processor operates in one of the defined privilege levels at all times: its operating privilege level. Only architectural state and instructions with a privilege level equal to or less than the operating privilege level can be accessed or executed, respectively. The initial operating privilege level of all processors is the highest supported privilege level.

Attempting to execute an instruction that requires a higher operating privilege level than the current one produces a precise exception (INSUFFICIENT PRIVILEGE). This exception has a privilege level that is one level higher than the operating privilege level used during the attempted execution.

The base architecture has two privilege levels:

• 0: Unprivileged
• 1: Privileged

The privilege level is specified as an unsigned integer. The privilege level specified corresponds to its magnitude; zero is unprivileged, and all values greater than zero are privileged. Architecture extensions may define additional privilege levels.

The base architecture does not define the architectural state and instructions for supporting privilege levels. These features must be defined as architecture extensions.




───────────────
6.2  Exceptions
───────────────


Exceptions are signals generated by instructions to indicate two facts:

• The instruction has encountered an exceptional condition. In this context, "exceptional" means the opposite of common. In practice, this may only be true in the aspirational sense.
• The exceptional condition can only be resolved by software that runs in a privilege level that is higher than the one the instruction ran in.

An exception causes the processor to stop receiving external interrupts, elevate its operating privilege level to the one required by the exception, and to transfer control to the exceptional condition-resolving software (such as an operating system's exception handler).

After the exceptional condition has been resolved, the privileged software returns from the exception by restoring the processor's former operating privilege level, and by transferring control back to the appropriate instruction.

Exceptions are internal to the processor that executed the exception-causing instruction. They do not modify any architectural state or cause a transfer of control in another processor or agent.

There are two types of exceptions: precise and imprecise. The type of exception generated depends on the nature of the condition.

Precise exceptions leave the processor architectural state as it was before the exception-causing instruction was executed (the exception-causing instruction does not modify any processor architectural state). The control transfer must occur immediately after the exception-causing instruction.

Imprecise exceptions allow the processor architectural state to be modified by instructions following the exception-causing instruction. The control transfer must occur eventually, but not necessarily immediately after the exception-causing instruction.

The defined exceptional condition that necessitated the exception is identified by its abstract exception identifier. This identifier is conceptual in nature, it does not have an integral value, and consequently cannot be used by implementations to represent the condition in any architectural state.

Implementations must define a concrete exception identifier, a unique integer code, for each abstract exception identifier. The base architecture does not define any concrete exception identifiers because implementations should devise their own optimal encoding.

Control is transferred to the first whole instruction in the instruction package located at the memory address registered for the exception condition-resolving software. At minimum, each privilege level used by exceptions has its own piece of exceptional condition-resolving software, which can handle all the exceptions that have the same privilege level. Architecture extensions may provide a mechanism for registering a memory address for exception condition-resolving software that are specialized for classes of exceptions or individual exceptions.

These registered memory addresses are contained in the processor's privileged architectural state. Each piece of state has the same the privilege level as that of the exceptions it serves.

At minimum, the exceptional condition-resolving software requires the following information in order to successfully resolve the exceptional condition:

• The operating privilege level the processor was in when it executed the exception-causing instruction.
• The memory address of the instruction package containing the exception-causing instruction. For instructions that span two instruction packages, the memory address is that of the instruction package that contains the leading part of the instruction.
• The integer that identifies which instruction inside an instruction package is the exception-causing instruction.
• The concrete exception identifier.

This information is written to the processor's architectural state when an exception is generated. There is a set of this state for each privilege level that is used by exceptions. The privilege level of this state is that of the software required to resolve the exceptional condition.

Architecture extensions may define additional information that is saved in order to successfully resolve the exceptional condition, or in order to improve the performance of resolving the exceptional condition.

The base architecture defines exceptions as requirements that must be met by all implementations. A functional computer system requires further treatment on exceptions that is outside the scope of the base architecture. Architecture extensions must complete the base architecture.

The base architecture permits this architecture extensions to redefine the privilege levels of exceptions to a higher level if necessary.




──────────────────────────────
Abstract Exception Identifiers
──────────────────────────────


• INSUFFICIENT PRIVILEGE

  Type: Precise
  Description: See Section 6.1, Privilege Levels


• INVALID INSTRUCTION

  Type: Precise
  Description: See Section 6.6, Instructions


• INVALID INSTRUCTION PACKAGE

  Type: Precise
  Description: See Section 6.6, Instructions


• INVALID INSTRUCTION PACKAGE FORMAT

  Type: Precise
  Description: See Section 6.6, Instructions


• INVALID SPANNED INSTRUCTION

  Type: Precise
  Description: See Section 6.6, Instructions


• UNALIGNED ELEMENT SELECT

  Type: Precise
  Description: See Part II, Section 23 (Element Extraction Instructions)
                   Part II, Section 24 (Element Deposition Instructions)


• UNALIGNED PRIMARY MEMORY ADDRESS

  Type: Precise
  Description: See Section 7.1, Addressing Characteristics




───────────────
6.3  Interrupts
───────────────


Interrupts are signals that request attention. There are two types of interrupts, based on the origin of the interrupt from the perspective of the processor that received it: internal and external.

Internal interrupts originate from the same processor that received it. They are a mechanism for less-privileged software to request attention from more-privileged software.

A processor generates internal interrupts by executing certain instructions. The privilege level of these interrupts is determined by the interrupt-generating instruction.

External interrupts originate from another processor or from an agent. They are a mechanism for processors and agents to request attention from a processor.

Processors can send interrupts to other processors and agents. Interrupts are sent by a processor to another processor or agent are unordered, but cannot be speculative. The interrupts received by a processor or agent do not have to be in the same order in which they were sent. Mechanisms to enforce interrupt ordering may be provided by architecture extensions.

External interrupts have the same privilege level as the instructions that generated them.

Processors can disable the reception of external interrupts. The reception of internal interrupts cannot be disabled.

An interrupt causes the processor to disable interrupts, change its operating privilege level to that of the interrupt (if it is not already in that level), and transfer control to the software handling the interrupt (such as an operating system's interrupt handler).

After the interrupt has been serviced, the interrupt-handling software returns from the interrupt by restoring the processor's former operating privilege level (if necessary), and by transferring control to the appropriate instruction.

Control is transferred to the first whole instruction in the instruction package at the memory address registered for the interrupt-handling software. At minimum, each privilege level used by an interrupts has its own piece of interrupt-handling software, which can handle all interrupts that have the same privilege level.

These registered memory addresses are contained the processor's privileged architecture state. Each piece of state has the same privilege level as that of the interrupts it serves.

The base architecture permits architecture extensions to redefine the privilege levels of interrupts to a higher level if necessary.

The base architecture defines interrupts as requirements that must be met by all implementations. A functional computer system requires further treatment on interrupts that is outside the scope of the base architecture. Architecture extensions must complete the base architecture.




─────────────────
6.4  Data Formats
─────────────────


Aura conceptualizes data as being either scalars or vectors. Scalars are singular entities that represent a quantity; vectors are homogeneous collections of elements, each a scalar. Scalars and vectors are comprised of units of data: a scalar is some kind of unit of data; a vector is a continuous series of a given unit of data. What the bits in a unit of data represent collectively is determined by its data format. The fundamental data formats are bit sets and integers.




────────
Bit Sets
────────


Bit sets are groups of continuous bits where the bits are treated individually, that is, only the value of each individual bit has meaning. Bit sets have five sizes: 8, 16, 32, 64, and 128 bits, corresponding to the five units of data, the octet, bi-octet, quadrant-word, semi-word, and word, respectively. Bit sets represent bitwise data or data formats that are not supported in Aura.




────────
Integers
────────


There are two forms of integer: unsigned and signed. Each form has five sizes: 8, 16, 32, 64, and 128 bits, corresponding to the five units of data: the octet, bi-octet, quadrant-word, semi-word, and word, respectively. For unsigned integers, bits increase in significance from left to right. Signed integers are represented with the two's complement representation. For signed integers, bits increase in significance from left to right, and the rightmost bit is the sign bit―and a value of zero indicates a positive integer, one indicates a negative integer. Both forms of integer wrap-around on overflow.


Unsigned Integer Numerical Ranges:

┌──────┬─────┬──────────────────────────────────────────────────────┐
│ Size │ MIN │                                                  MAX │
├──────┼─────┼──────────────────────────────────────────────────────┤
│    8 │   0 │                                                  255 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│   16 │   0 │                                               65,535 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│   32 │   0 │                                        4,294,967,295 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│   64 │   0 │                           18,446,744,073,709,551,615 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│  128 │   0 │  340,282,366,920,938,463,463,374,607,431,768,211,455 │
└──────┴─────┴──────────────────────────────────────────────────────┘


Signed Integer Numerical Ranges:

┌──────┬─────┬──────────────────────────────────────────────────────┐
│ Size │     │                                                      │
├──────┼─────┼──────────────────────────────────────────────────────┤
│    8 │ MIN │                                                 −128 │
│      │ MAX │                                                  127 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│   16 │ MIN │                                              −32,768 │
│      │ MAX │                                               32,767 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│   32 │ MIN │                                       −2,147,483,648 │
│      │ MAX │                                        2,147,483,647 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│   64 │ MIN │                           −9,223,372,036,854,775,808 │
│      │ MAX │                            9,223,372,036,854,775,807 │
├──────┼─────┼──────────────────────────────────────────────────────┤
│  128 │ MIN │ −170,141,183,460,469,231,731,687,303,715,884,105,728 │
│      │ MAX │  170,141,183,460,469,231,731,687,303,715,884,105,727 │
└──────┴─────┴──────────────────────────────────────────────────────┘




────────────
Real Numbers
────────────


Aura does not support any real number data formats in the base architecture. All support for real numbers, both data formats and instructions, must be provided by architecture extensions. The base architecture does not support real numbers because of the relative impermanence of real number representations compared to those for integers.




───────
Vectors
───────


Aura vectors are collections of elements that have these characteristics:

• All elements in a vector are independent of every other element.
• Elements may be of the following units of data: the 8-bit octet, 16-bit bi-octet, 32-bit quadrant-word, 64-bit semi-word, and 128-bit word.
• All elements in a vector must be of the same unit of data.
• The length of a vector in bits must a positive integral multiple of 128. This ensures that vectors may be stored at any word address (see Section 7.1, Addressing Characteristics). The effect of this requirement is that the number of elements in a vector with elements that are sub-word units of data will be the multiple of the number of sub-word units that can fit within a word.

Vectors conforming to the above definition are intended to be provided by architecture extensions and not featured in the base architecture. Instead, the base architecture features 128-bit vectors, which are sized identically to words, so they can be tightly coupled with scalar processing by fitting inside the 128-bit GPRs and RNRs. There are four vector types, V2, V4, V8, and V16, named for the number of elements they contain. The characteristics of these vectors are given in the following table:


┌────────┬────────────┬─────────┐
│ Vector │ Vector     │ Element │
│ Type   │ Length     │ Size    │
│        │ (Elements) │ (Bits)  │
├────────┼────────────┼─────────┤
│ V2     │ 2          │ 64      │
├────────┼────────────┼─────────┤
│ V4     │ 4          │ 32      │
├────────┼────────────┼─────────┤
│ V8     │ 8          │ 16      │
├────────┼────────────┼─────────┤
│ V16    │ 16         │ 8       │
└────────┴────────────┴─────────┘


The layout of elements in a vector is given in the following tables:


V2 Layout:

┌─────────┬─────┬─────┐
│ Element │ MSB │ LSB │
├─────────┼─────┼─────┤
│ 0       │  63 │   0 │
│ 1       │ 127 │  64 │
└─────────┴─────┴─────┘


V4 Layout:

┌─────────┬─────┬─────┐
│ Element │ MSB │ LSB │
├─────────┼─────┼─────┤
│ 0       │  31 │   0 │
│ 1       │  63 │  32 │
│ 2       │  95 │  64 │
│ 3       │ 127 │  96 │
└─────────┴─────┴─────┘


V8 Layout:

┌─────────┬─────┬─────┐
│ Element │ MSB │ LSB │
├─────────┼─────┼─────┤
│ 0       │  15 │   0 │
│ 1       │  31 │  16 │
│ 2       │  47 │  32 │
│ 3       │  63 │  48 │
│ 4       │  79 │  64 │
│ 5       │  95 │  80 │
│ 6       │ 111 │  96 │
│ 7       │ 127 │ 112 │
└─────────┴─────┴─────┘


V16 Layout:

┌─────────┬─────┬─────┐
│ Element │ MSB │ LSB │
├─────────┼─────┼─────┤
│  0      │   7 │   0 │
│  1      │  15 │   8 │
│  2      │  23 │  16 │
│  3      │  31 │  24 │
│  4      │  39 │  32 │
│  5      │  47 │  40 │
│  6      │  55 │  48 │
│  7      │  63 │  56 │
│  8      │  71 │  64 │
│  9      │  79 │  72 │
│ 10      │  87 │  80 │
│ 11      │  95 │  88 │
│ 12      │ 103 │  96 │
│ 13      │ 111 │ 104 │
│ 14      │ 119 │ 112 │
│ 15      │ 127 │ 120 │
└─────────┴─────┴─────┘








────────────────────────
6.5  Architectural State
────────────────────────


Each processor has the following architectural state:

• An instruction package memory address register (IPMAR)
• A general-purpose register (GPR) set
• A carry register (CR) set
• A real number register (RNR) set

Bits in all registers are numbered starting from zero. The first bit is the least-significant bit.

The architectural state has a privilege level of 0 (Unprivileged).

All registers have an unpredictable initial value, except for the IPMAR, which has an initial value of 128'B0.




───────────────────────────────────────────────────
Instruction Package Memory Address Register (IPMAR)
───────────────────────────────────────────────────


The IPMAR is a 128-bit register that holds the 128-bit memory address of an instruction package. This memory address is a word address―it addresses the primary memory as 128-bit words (for further details on memory addressing, see Section 7, Primary Memory).

The memory address identifies the instruction package containing the instruction being executed. If the instruction spans two instruction packages, then the memory address identifies the instruction package that contains the leading part of the instruction being executed (for further details on instruction layout in instruction packages, see Section 6.6, Instructions).




──────────────────────────────────
General Purpose Register (GPR) Set
──────────────────────────────────


The GPR set contains sixty-four 128-bit registers, which are identified by the register numbers GPR[0]—GPR[63]. Each GPR can be divided into two 64-bit halves called semi-GPRs (SGPRs) that function independently. Thus, an alternative view of the GPR set is as a SGPR set containing one hundred and twenty-eight 64-bit registers, which are identified by the register numbers SGPR[0]—SGPR[127].

A SGPR is mapped to the GPR whose register number is the integer quotient of the SGPR's register number and '2'. The modulo of the SGPR's register number and '2' determines which half of the GPR the SGPR is mapped to: '0' corresponds to the low-order half, and '1' to the high-order half.

GPRs are mainly intended to hold scalar and vector bit sets and integers for memory addressing and computation. SGPRs are mainly intended to hold scalar and vector bit sets and integers for computation.




───────────────────────
Carry Register (CR) Set
───────────────────────


The CR set contains one hundred and twenty-eight 1-bit registers, which are identified by the register numbers CR[0]—CR[127]. Each GPR and SGPR is associated with the CR that the same register number.

The CRs are used to accommodate the most-significant bit of the 65- or 129-bit results produced by some integer instructions. Since there are 64 GPRs and 128 SGPRs, CR[0]—CR[63] are associated with both GPR[0]—GPR[63] and SGPR[0]—SGPR[63], while CR[64]—CR[127] are exclusively associated with SGPRs. Because the SGPRs are mapped onto GPRs, when an instruction writes to a GPR, two SGPRs are overwritten. The two CRs that are associated with the two SGPRs mapped to a GPR are written to: the CR that is associated with the GPR receives the valid CR value; while the CR that is exclusively associated with the SGPR is zeroed.




──────────────────────────────
Real Number Register (RNR) Set
──────────────────────────────


The RNR set contains sixty-four 128-bit registers, which are identified by its register number RNR[0]—RNR[63]. Each RNR can be divided into two 64-bit halves called semi-RNRs (SRNRs) that function independently. Thus, an alternative view of the RNR set is as a SRNR set containing one hundred and twenty-eight 64-bit registers, which are identified by the register numbers SRNR[0]—SRNR[127].

A SRNR is mapped to the RNR whose register number is the integer quotient of the SRNR's register number and '2'. The modulo of the SRNR's register number and '2' determines which half of the RNR the SRNR is mapped to: '0' corresponds to the low-order half, and '1' to the high-order half.

RNRs and SRNRs are mainly intended for holding real numbers for scalar and vector computation, and the integer operands and results of instructions that consume or produce integers.




─────────────────
6.6  Instructions
─────────────────


Instructions are 30, 40, 50, or 60 bits long. Multiple instructions are packaged into 128-bit words called 'instruction packages' because they do not correspond to any unit of data and are not addressable. Consequently, instructions are generally addressed indirectly at the instruction package level, and the architecture does not expose the addressing of instructions within an instruction package in most cases.

To improve code density, instructions that cannot fit into an instruction package are split into two parts: the low-order part is the 'leading part' and the high-order part is the 'trailing part'. These parts are placed into two adjacent instruction packages. The leading part resides in the instruction package with the smaller memory address; the trailing part resides in the instruction package with the larger memory address (this convention is reversed if the instruction package containing the low-order part of the instruction is stored in the last word in the primary memory because of memory address warp-around).

The first instruction in an instruction package is the first wholly contained instruction. An instruction's trailing part is considered to belong to the instruction package containing its leading part. The memory address of such an instruction is the memory address of the instruction package containing its leading part.

Instruction packages consists of two parts: an 8-bit 'Format' field that occupies bits 0—7, and a 120-bit 'Payload' field that occupies bits 8—127.

The Format field is an 8-bit unsigned integer that specifies the format of the Payload field. The format determines the number of instructions in the Payload field, the sizes of these instructions, the positions of these instructions in the Payload field, whether or not there is a leading part of instruction from the previous instruction package, whether or not the last instruction in the instruction package crosses instruction packages, and whether or not there is a 'Zero' field.

There are 157 formats that permit the instruction package to accommodate all combinations of the aforementioned features. The Format field has 256 possible values, of which 157 are assigned to the defined formats. All unused values are reserved. An instruction package with a Format field that contains an unused value causes a precise exception (INVALID INSTRUCTION PACKAGE FORMAT) to be generated. This exception has a privilege level of 1 (Privileged).

The length of an instruction that crosses instruction packages is determined by the Format fields of the two instruction packages that contains its parts. The Format fields of instruction package pairs must be in agreement in regards to whether or not there is an instruction crossing their boundary, and the length of this instruction if one exists. Otherwise, a precise exception (INVALID SPANNED INSTRUCTION) is generated.

To elaborate, if the first instruction package in a pair has a 40-bit leading part of an instruction in bits 80—119 of its Payload field, then the second instruction package must have either a 10- or 20-bit trailing part of an instruction in bits 0—9 or 0—19, respectively.

The later instruction package cannot lack a trailing part of an instruction because the earlier instruction package has a leading part of an instruction. Also, the second instruction package cannot have a trailing part of an instruction greater than 50 bits in length because an instruction's maximum length is 60 bits.

The requirement for the Format fields of the current and previous instruction packages to agree is waived at initialization and when there is a transfer of control (such as branch to another instruction package), since it would not make sense for there to be spanned instructions in these cases. The requirement is not enforced until execution has advanced sufficiently to have caused the IPMAR to be incremented.

Some instruction package formats have a 'Zero' sub-field in the high-order 10 or 20 bits of the Payload field. This sub-field does not contain any part of an instruction and is filled with zeros. If this invariant does not hold, an INVALID INSTRUCTION PACKAGE is generated.

The primary purpose of the 'Zero' field is to terminate basic blocks that cannot fill the last instruction package's Payload field with an instruction due to insufficient space. This ensures maximum instruction density by not requiring an unnecessary NULL instruction (that would cross instruction packages). The secondary purpose is to improve performance by prevent an instruction from crossing instruction packages if doing so will cause a reduction in performance.

Instructions in an instruction package are executed sequentially (unless there is a control flow instruction or some kind of event such as an exception or interrupt). Execution begins at the first instruction in an instruction package. A precise exception (INVALID INSTRUCTION) is generated when an unrecognized instruction is encountered. This exception has a privilege level of 1 (Privileged).




─────────────────────
Payload Field Formats
─────────────────────


Legend:

• The Format code is specified as a decimal number to the right of each format.
• Each sub-field contains a letter that identifies what the sub-field is:
    • I: Instruction
    • L: Leading Part (of an instruction)
    • T: Trailing Part (of an instruction)
    • Z: Zero Sub-field
• The number in parentheses is the number of bits in the sub-field.
• The number after the colon of 'I' subfields identifies whether the instruction is the first, second, third, or fourth instruction in the instruction package.
• Some 'I' sub-fields have an 'L' after the colon and number. This indicates that the subfield is the leading part of an instruction that crosses instruction packages.


┌───────────┬─────────────────┬─────────────────┬─────────────────┬─────┐
│    Z (20) │        I:2 (30) │        I:1 (30) │        I:0 (30) │   T │   0
│           │                 │                 │                 │ (10)│
├───────────┼─────────────────┼─────────────────┼─────────────────┼─────┤
│ I:3L (20) │        I:2 (30) │        I:1 (30) │        I:0 (30) │   T │   1
│           │                 │                 │                 │ (10)│
├─────┬─────┴─────────────────┼─────────────────┼─────────────────┼─────┤
│   Z │              I:2 (40) │        I:1 (30) │        I:0 (30) │   T │   2
│ (10)│                       │                 │                 │ (10)│
├─────┼───────────────────────┼─────────────────┼─────────────────┼─────┤
│ I:3L│              I:2 (40) │        I:1 (30) │        I:0 (30) │   T │   3
│ (10)│                       │                 │                 │ (10)│
├─────┴───────────────────────┼─────────────────┼─────────────────┼─────┤
│                    I:2 (50) │        I:1 (30) │        I:0 (30) │   T │   4
│                             │                 │                 │ (10)│
├─────────────────────────────┼─────────────────┼─────────────────┼─────┤
│                   I:2L (50) │        I:1 (30) │        I:0 (30) │   T │   5
│                             │                 │                 │ (10)│
├─────┬─────────────────┬─────┴─────────────────┼─────────────────┼─────┤
│   Z │        I:2 (30) │              I:1 (40) │        I:0 (30) │   T │   6
│ (10)│                 │                       │                 │ (10)│
├─────┼─────────────────┼───────────────────────┼─────────────────┼─────┤
│ I:3L│        I:2 (30) │              I:1 (40) │        I:0 (30) │   T │   7
│ (10)│                 │                       │                 │ (10)│
├─────┴─────────────────┼───────────────────────┼─────────────────┼─────┤
│              I:2 (40) │              I:1 (40) │        I:0 (30) │   T │   8
│                       │                       │                 │ (10)│
├───────────────────────┼───────────────────────┼─────────────────┼─────┤
│             I:2L (40) │              I:1 (40) │        I:0 (30) │   T │   9
│                       │                       │                 │ (10)│
├─────────────────┬─────┴───────────────────────┼─────────────────┼─────┤
│        I:2 (30) │                    I:1 (50) │        I:0 (30) │   T │  10
│                 │                             │                 │ (10)│
├─────────────────┼─────────────────────────────┼─────────────────┼─────┤
│       I:2L (30) │                    I:1 (50) │        I:0 (30) │   T │  11
│                 │                             │                 │ (10)│
├───────────┬─────┴─────────────────────────────┼─────────────────┼─────┤
│    Z (20) │                          I:1 (60) │        I:0 (30) │   T │  12
│           │                                   │                 │ (10)│
├───────────┼───────────────────────────────────┼─────────────────┼─────┤
│ I:2L (20) │                          I:1 (60) │        I:0 (30) │   T │  13
│           │                                   │                 │ (10)│
├─────┬─────┴───────────┬─────────────────┬─────┴─────────────────┼─────┤
│   Z │        I:2 (30) │        I:1 (30) │              I:0 (40) │   T │  14
│ (10)│                 │                 │                       │ (10)│
├─────┼─────────────────┼─────────────────┼───────────────────────┼─────┤
│ I:3L│        I:2 (30) │        I:1 (30) │              I:0 (40) │   T │  15
│ (10)│                 │                 │                       │ (10)│
├─────┴─────────────────┼─────────────────┼───────────────────────┼─────┤
│              I:2 (40) │        I:1 (30) │              I:0 (40) │   T │  16
│                       │                 │                       │ (10)│
├───────────────────────┼─────────────────┼───────────────────────┼─────┤
│             I:2L (40) │        I:1 (30) │              I:0 (40) │   T │  17
│                       │                 │                       │ (10)│
├─────────────────┬─────┴─────────────────┼───────────────────────┼─────┤
│        I:2 (30) │              I:1 (40) │              I:0 (40) │   T │  18
│                 │                       │                       │ (10)│
├─────────────────┼───────────────────────┼───────────────────────┼─────┤
│       I:2L (30) │              I:1 (40) │              I:0 (40) │   T │  19
│                 │                       │                       │ (10)│
├───────────┬─────┴───────────────────────┼───────────────────────┼─────┤
│       Z   │                    I:1 (50) │              I:0 (40) │   T │  20
│      (20) │                             │                       │ (10)│
├───────────┼─────────────────────────────┼───────────────────────┼─────┤
│ I:2L (20) │                    I:1 (50) │              I:0 (40) │   T │  21
│           │                             │                       │ (10)│
├─────┬─────┴─────────────────────────────┼───────────────────────┼─────┤
│   Z │                          I:1 (60) │              I:0 (40) │   T │  22
│ (10)│                                   │                       │ (10)│
├─────┼───────────────────────────────────┼───────────────────────┼─────┤
│ I:2L│                          I:1 (60) │              I:0 (40) │   T │  23
│ (10)│                                   │                       │ (10)│
├─────┴───────────┬─────────────────┬─────┴───────────────────────┼─────┤
│        I:2 (30) │        I:1 (30) │                    I:0 (50) │   T │  24
│                 │                 │                             │ (10)│
├─────────────────┼─────────────────┼─────────────────────────────┼─────┤
│        I:2 L:30 │        I:1 (30) │                    I:0 (50) │   T │  25
│                 │                 │                             │ (10)│
├───────────┬─────┴─────────────────┼─────────────────────────────┼─────┤
│    Z (20) │              I:1 (40) │                    I:0 (50) │   T │  26
│           │                       │                             │ (10)│
├───────────┼───────────────────────┼─────────────────────────────┼─────┤
│ I:2L (20) │              I:1 (40) │                    I:0 (50) │   T │  27
│           │                       │                             │ (10)│
├─────┬─────┴───────────────────────┼─────────────────────────────┼─────┤
│   Z │                    I:1 (50) │                    I:0 (50) │   T │  28
│ (10)│                             │                             │ (10)│
├─────┼─────────────────────────────┼─────────────────────────────┼─────┤
│ I:2L│                    I:1 (50) │                    I:0 (50) │   T │  29
│ (10)│                             │                             │ (10)│
├─────┴─────────────────────────────┼─────────────────────────────┼─────┤
│                          I:1 (60) │                    I:0 (50) │   T │  30
│                                   │                             │ (10)│
├───────────┬─────────────────┬─────┴─────────────────────────────┼─────┤
│    Z (20) │        I:1 (30) │                          I:0 (60) │   T │  31
│           │                 │                                   │ (10)│
├───────────┼─────────────────┼───────────────────────────────────┼─────┤
│ I:2L (20) │        I:1 (30) │                          I:0 (60) │   T │  32
│           │                 │                                   │ (10)│
├─────┬─────┴─────────────────┼───────────────────────────────────┼─────┤
│   Z │              I:1 (40) │                          I:0 (60) │   T │  33
│ (10)│                       │                                   │ (10)│
├─────┼───────────────────────┼───────────────────────────────────┼─────┤
│ I:2L│              I:1 (40) │                          I:0 (60) │   T │  34
│ (10)│                       │                                   │ (10)│
├─────┴───────────────────────┼───────────────────────────────────┼─────┤
│                    I:1 (50) │                          I:0 (60) │   T │  35
│                             │                                   │ (10)│
├─────────────────────────────┼───────────────────────────────────┼─────┤
│                   I:1L (50) │                          I:0 (60) │   T │  36
│                             │                                   │ (10)│
├─────┬─────────────────┬─────┴───────────┬─────────────────┬─────┴─────┤
│   Z │        I:2 (30) │        I:1 (30) │        I:0 (30) │    T (20) │  37
│ (10)│                 │                 │                 │           │
├─────┼─────────────────┼─────────────────┼─────────────────┼───────────┤
│ I:3L│        I:2 (30) │        I:1 (30) │        I:0 (30) │    T (20) │  38
│ (10)│                 │                 │                 │           │
├─────┴─────────────────┼─────────────────┼─────────────────┼───────────┤
│              I:2 (40) │        I:1 (30) │        I:0 (30) │    T (20) │  39
├───────────────────────┼─────────────────┼─────────────────┼───────────┤
│             I:2L (40) │        I:1 (30) │        I:0 (30) │    T (20) │  40
├─────────────────┬─────┴─────────────────┼─────────────────┼───────────┤
│        I:2 (30) │              I:1 (40) │        I:0 (30) │    T (20) │  41
├─────────────────┼───────────────────────┼─────────────────┼───────────┤
│       I:2L (30) │              I:1 (40) │        I:0 (30) │    T (20) │  42
├───────────┬─────┴───────────────────────┼─────────────────┼───────────┤
│    Z (20) │                    I:1 (50) │        I:0 (30) │    T (20) │  43
├───────────┼─────────────────────────────┼─────────────────┼───────────┤
│ I:2L (20) │                    I:1 (50) │        I:0 (30) │    T (20) │  44
├─────┬─────┴─────────────────────────────┼─────────────────┼───────────┤
│   Z │                          I:1 (60) │        I:0 (30) │    T (20) │  45
│ (10)│                                   │                 │           │
├─────┼───────────────────────────────────┼─────────────────┼───────────┤
│ I:2L│                          I:1 (60) │        I:0 (30) │    T (20) │  46
│ (10)│                                   │                 │           │
├─────┴───────────┬─────────────────┬─────┴─────────────────┼───────────┤
│        I:2 (30) │        I:1 (30) │              I:0 (40) │    T (20) │  47
├─────────────────┼─────────────────┼───────────────────────┼───────────┤
│       I:2L (30) │        I:1 (30) │              I:0 (40) │    T (20) │  48
├───────────┬─────┴─────────────────┼───────────────────────┼───────────┤
│    Z (20) │              I:1 (40) │              I:0 (40) │    T (20) │  49
├───────────┼───────────────────────┼───────────────────────┼───────────┤
│ I:2L (20) │              I:1 (40) │              I:0 (40) │    T (20) │  50
├─────┬─────┴───────────────────────┼───────────────────────┼───────────┤
│   Z │                    I:1 (50) │              I:0 (40) │    T (20) │  51
│ (10)│                             │                       │           │
├─────┼─────────────────────────────┼───────────────────────┼───────────┤
│ I:2L│                    I:1 (50) │              I:0 (40) │    T (20) │  52
│ (10)│                             │                       │           │
├─────┴─────────────────────────────┼───────────────────────┼───────────┤
│                          I:1 (60) │              I:0 (40) │    T (20) │  53
├───────────┬─────────────────┬─────┴───────────────────────┼───────────┤
│    Z (20) │        I:1 (30) │                    I:0 (50) │    T (20) │  54
├───────────┼─────────────────┼─────────────────────────────┼───────────┤
│ I:2L (20) │        I:1 (30) │                    I:0 (50) │    T (20) │  55
├─────┬─────┴─────────────────┼─────────────────────────────┼───────────┤
│   Z │              I:1 (40) │                    I:0 (50) │    T (20) │  56
│ (10)│                       │                             │           │
├─────┼───────────────────────┼─────────────────────────────┼───────────┤
│ I:2L│              I:1 (40) │                    I:0 (50) │    T (20) │  57
│ (10)│                       │                             │           │
├─────┴───────────────────────┼─────────────────────────────┼───────────┤
│                    I:1 (50) │                    I:0 (50) │    T (20) │  58
├─────────────────────────────┼─────────────────────────────┼───────────┤
│                   I:1L (50) │                    I:0 (50) │    T (20) │  59
├─────┬─────────────────┬─────┴─────────────────────────────┼───────────┤
│   Z │        I:1 (30) │                          I:0 (60) │    T (20) │  60
│ (10)│                 │                                   │           │
├─────┼─────────────────┼───────────────────────────────────┼───────────┤
│ I:2L│        I:1 (30) │                          I:0 (60) │    T (20) │  61
│ (10)│                 │                                   │           │
├─────┴─────────────────┼───────────────────────────────────┼───────────┤
│              I:1 (40) │                          I:0 (60) │    T (20) │  62
├───────────────────────┼───────────────────────────────────┼───────────┤
│             I:1L (40) │                          I:0 (60) │    T (20) │  63
├─────────────────┬─────┴───────────┬─────────────────┬─────┴───────────┤
│        I:2 (30) │        I:1 (30) │        I:0 (30) │          T (30) │  64
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│       I:2L (30) │        I:1 (30) │        I:0 (30) │          T (30) │  65
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│        I:3 (30) │        I:2 (30) │        I:1 (30) │        I:0 (30) │  66
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│       I:3L (30) │        I:2 (30) │        I:1 (30) │        I:0 (30) │  67
├───────────┬─────┴─────────────────┼─────────────────┼─────────────────┤
│    Z (20) │              I:1 (40) │        I:0 (30) │          T (30) │  68
├───────────┼───────────────────────┼─────────────────┼─────────────────┤
│ I:2L (20) │              I:1 (40) │        I:0 (30) │          T (30) │  69
├───────────┼───────────────────────┼─────────────────┼─────────────────┤
│    Z (20) │              I:2 (40) │        I:1 (30) │        I:0 (30) │  70
├───────────┼───────────────────────┼─────────────────┼─────────────────┤
│ I:3L (20) │              I:2 (40) │        I:1 (30) │        I:0 (30) │  71
├─────┬─────┴───────────────────────┼─────────────────┼─────────────────┤
│   Z │                    I:1 (50) │        I:0 (30) │          T (30) │  72
│ (10)│                             │                 │                 │
├─────┼─────────────────────────────┼─────────────────┼─────────────────┤
│ I:2L│                    I:1 (50) │        I:0 (30) │          T (30) │  73
│ (10)│                             │                 │                 │
├─────┼─────────────────────────────┼─────────────────┼─────────────────┤
│   Z │                    I:2 (50) │        I:1 (30) │        I:0 (30) │  74
│ (10)│                             │                 │                 │
├─────┼─────────────────────────────┼─────────────────┼─────────────────┤
│ I:3L│                    I:2 (50) │        I:1 (30) │        I:0 (30) │  75
│ (10)│                             │                 │                 │
├─────┴─────────────────────────────┼─────────────────┼─────────────────┤
│                          I:1 (60) │        I:0 (30) │          T (30) │  76
├───────────────────────────────────┼─────────────────┼─────────────────┤
│                          I:2 (60) │        I:1 (30) │        I:0 (30) │  77
├───────────┬─────────────────┬─────┴─────────────────┼─────────────────┤
│    Z (20) │        I:1 (30) │              I:0 (40) │          T (30) │  78
├───────────┼─────────────────┼───────────────────────┼─────────────────┤
│ I:2L (20) │        I:1 (30) │              I:0 (40) │          T (30) │  79
├───────────┼─────────────────┼───────────────────────┼─────────────────┤
│    Z (20) │        I:2 (30) │              I:1 (40) │        I:0 (30) │  80
├───────────┼─────────────────┼───────────────────────┼─────────────────┤
│ I:3L (20) │        I:2 (30) │              I:1 (40) │        I:0 (30) │  81
├─────┬─────┴─────────────────┼───────────────────────┼─────────────────┤
│   Z │              I:1 (40) │              I:0 (40) │          T (30) │  82
│ (10)│                       │                       │                 │
├─────┼───────────────────────┼───────────────────────┼─────────────────┤
│ I:2L│              I:1 (40) │              I:0 (40) │          T (30) │  83
│ (10)│                       │                       │                 │
├─────┼───────────────────────┼───────────────────────┼─────────────────┤
│   Z │              I:2 (40) │              I:1 (40) │        I:0 (30) │  84
│ (10)│                       │                       │                 │
├─────┼───────────────────────┼───────────────────────┼─────────────────┤
│ I:3L│              I:2 (40) │              I:1 (40) │        I:0 (30) │  85
│ (10)│                       │                       │                 │
├─────┴───────────────────────┼───────────────────────┼─────────────────┤
│                    I:1 (50) │              I:0 (40) │          T (30) │  86
├─────────────────────────────┼───────────────────────┼─────────────────┤
│                   I:1L (50) │              I:0 (40) │          T (30) │  87
├─────────────────────────────┼───────────────────────┼─────────────────┤
│                    I:2 (50) │              I:1 (40) │        I:0 (30) │  88
├─────────────────────────────┼───────────────────────┼─────────────────┤
│                   I:2L (50) │              I:1 (40) │        I:0 (30) │  89
├─────┬─────────────────┬─────┴───────────────────────┼─────────────────┤
│   Z │        I:1 (30) │                    I:0 (50) │          T (30) │  90
│ (10)│                 │                             │                 │
├─────┼─────────────────┼─────────────────────────────┼─────────────────┤
│ I:2L│        I:1 (30) │                    I:0 (50) │          T (30) │  91
│ (10)│                 │                             │                 │
├─────┼─────────────────┼─────────────────────────────┼─────────────────┤
│   Z │        I:2 (30) │                    I:1 (50) │        I:0 (30) │  92
│ (10)│                 │                             │                 │
├─────┼─────────────────┼─────────────────────────────┼─────────────────┤
│ I:3L│        I:2 (30) │                    I:1 (50) │        I:0 (30) │  93
│ (10)│                 │                             │                 │
├─────┴─────────────────┼─────────────────────────────┼─────────────────┤
│              I:1 (40) │                    I:0 (50) │          T (30) │  94
├───────────────────────┼─────────────────────────────┼─────────────────┤
│             I:1L (40) │                    I:0 (50) │          T (30) │  95
├───────────────────────┼─────────────────────────────┼─────────────────┤
│              I:2 (40) │                    I:1 (50) │        I:0 (30) │  96
├───────────────────────┼─────────────────────────────┼─────────────────┤
│             I:2L (40) │                    I:1 (50) │        I:0 (30) │  97
├─────────────────┬─────┴─────────────────────────────┼─────────────────┤
│        I:1 (30) │                          I:0 (60) │          T (30) │  98
├─────────────────┼───────────────────────────────────┼─────────────────┤
│       I:1L (30) │                          I:0 (60) │          T (30) │  99
├─────────────────┼───────────────────────────────────┼─────────────────┤
│        I:2 (30) │                          I:1 (60) │        I:0 (30) │ 100
├─────────────────┼───────────────────────────────────┼─────────────────┤
│       I:2L (30) │                          I:1 (60) │        I:0 (30) │ 101
├───────────┬─────┴───────────┬─────────────────┬─────┴─────────────────┤
│    Z (20) │        I:1 (30) │        I:0 (30) │                T (40) │ 102
├───────────┼─────────────────┼─────────────────┼───────────────────────┤
│ I:2L (20) │        I:1 (30) │        I:0 (30) │                T (40) │ 103
├───────────┼─────────────────┼─────────────────┼───────────────────────┤
│    Z (20) │        I:2 (30) │        I:1 (30) │              I:0 (40) │ 104
├───────────┼─────────────────┼─────────────────┼───────────────────────┤
│ I:3L (30) │        I:2 (30) │        I:1 (30) │              I:0 (40) │ 105
├─────┬─────┴─────────────────┼─────────────────┼───────────────────────┤
│   Z │              I:1 (40) │        I:0 (30) │                T (40) │ 106
│ (10)│                       │                 │                       │
├─────┼───────────────────────┼─────────────────┼───────────────────────┤
│ I:2L│              I:1 (40) │        I:0 (30) │                T (40) │ 107
│ (10)│                       │                 │                       │
├─────┼───────────────────────┼─────────────────┼───────────────────────┤
│   Z │              I:2 (40) │        I:1 (30) │              I:0 (40) │ 108
│ (10)│                       │                 │                       │
├─────┼───────────────────────┼─────────────────┼───────────────────────┤
│ I:3L│              I:2 (40) │        I:1 (30) │              I:0 (40) │ 109
│ (10)│                       │                 │                       │
├─────┴───────────────────────┼─────────────────┼───────────────────────┤
│                    I:1 (50) │        I:0 (30) │                T (40) │ 110
├─────────────────────────────┼─────────────────┼───────────────────────┤
│                   I:1L (50) │        I:0 (30) │                T (40) │ 111
├─────────────────────────────┼─────────────────┼───────────────────────┤
│                    I:2 (50) │        I:0 (30) │              I:0 (40) │ 112
├─────────────────────────────┼─────────────────┼───────────────────────┤
│                   I:2L (50) │        I:0 (30) │              I:0 (40) │ 113
├─────┬─────────────────┬─────┴─────────────────┼───────────────────────┤
│   Z │        I:1 (30) │              I:0 (40) │                T (40) │ 114
│ (10)│                 │                       │                       │
├─────┼─────────────────┼───────────────────────┼───────────────────────┤
│ 1:2L│        I:1 (30) │              I:0 (40) │                T (40) │ 115
│ (10)│                 │                       │                       │
├─────┼─────────────────┼───────────────────────┼───────────────────────┤
│   Z │        I:2 (30) │              I:1 (40) │              I:0 (40) │ 116
│ (10)│                 │                       │                       │
├─────┼─────────────────┼───────────────────────┼───────────────────────┤
│ 1:3L│        I:2 (30) │              I:1 (40) │              I:0 (40) │ 117
│ (10)│                 │                       │                       │
├─────┴─────────────────┼───────────────────────┼───────────────────────┤
│              I:1 (40) │              I:0 (40) │                T (40) │ 118
├───────────────────────┼───────────────────────┼───────────────────────┤
│             I:1L (40) │              I:0 (40) │                T (40) │ 119
├───────────────────────┼───────────────────────┼───────────────────────┤
│              I:2 (40) │              I:1 (40) │              I:0 (40) │ 120
├───────────────────────┼───────────────────────┼───────────────────────┤
│             I:2L (40) │              I:1 (40) │              I:0 (40) │ 121
├─────────────────┬─────┴───────────────────────┼───────────────────────┤
│        I:1 (30) │                    I:0 (50) │                T (40) │ 122
├─────────────────┼─────────────────────────────┼───────────────────────┤
│       I:1L (30) │                    I:0 (50) │                T (40) │ 123
├─────────────────┼─────────────────────────────┼───────────────────────┤
│        I:2 (30) │                    I:1 (50) │              I:0 (40) │ 124
├─────────────────┼─────────────────────────────┼───────────────────────┤
│       I:2L (40) │                    I:1 (50) │              I:0 (40) │ 125
├───────────┬─────┴─────────────────────────────┼───────────────────────┤
│    Z (20) │                          I:0 (60) │                T (40) │ 126
├───────────┼───────────────────────────────────┼───────────────────────┤
│ I:1L (20) │                          I:0 (60) │                T (40) │ 127
├───────────┼───────────────────────────────────┼───────────────────────┤
│    Z (20) │                          I:1 (60) │              I:0 (40) │ 128
├───────────┼───────────────────────────────────┼───────────────────────┤
│ I:2L (20) │                          I:1 (60) │              I:0 (40) │ 129
├─────┬─────┴───────────┬─────────────────┬─────┴───────────────────────┤
│   Z │        I:1 (30) │        I:0 (30) │                      T (50) │ 130
│ (10)│                 │                 │                             │
├─────┼─────────────────┼─────────────────┼─────────────────────────────┤
│ I:2L│        I:1 (30) │        I:0 (30) │                      T (50) │ 131
│ (10)│                 │                 │                             │
├─────┼─────────────────┼─────────────────┼─────────────────────────────┤
│   Z │        I:2 (30) │        I:1 (30) │                    I:0 (50) │ 132
│ (10)│                 │                 │                             │
├─────┼─────────────────┼─────────────────┼─────────────────────────────┤
│ I:3L│        I:2 (30) │        I:1 (30) │                    I:0 (50) │ 133
│ (10)│                 │                 │                             │
├─────┴─────────────────┼─────────────────┼─────────────────────────────┤
│              I:1 (40) │        I:0 (30) │                      T (50) │ 134
├───────────────────────┼─────────────────┼─────────────────────────────┤
│             I:1L (40) │        I:0 (30) │                      T (50) │ 135
├───────────────────────┼─────────────────┼─────────────────────────────┤
│              I:2 (40) │        I:1 (30) │                    I:0 (50) │ 136
├───────────────────────┼─────────────────┼─────────────────────────────┤
│             I:2L (40) │        I:1 (30) │                    I:0 (50) │ 137
├─────────────────┬─────┴─────────────────┼─────────────────────────────┤
│        I:1 (30) │              I:0 (40) │                      T (50) │ 138
├─────────────────┼───────────────────────┼─────────────────────────────┤
│       I:1L (30) │              I:0 (40) │                      T (50) │ 139
├─────────────────┼───────────────────────┼─────────────────────────────┤
│        I:2 (30) │              I:1 (40) │                    I:0 (50) │ 140
├─────────────────┼───────────────────────┼─────────────────────────────┤
│       I:2L (30) │              I:1 (40) │                    I:0 (50) │ 141
├───────────┬─────┴───────────────────────┼─────────────────────────────┤
│    Z (20) │                    I:0 (50) │                      T (50) │ 142
├───────────┼─────────────────────────────┼─────────────────────────────┤
│ I:1L (20) │                    I:0 (50) │                      T (50) │ 143
├───────────┼─────────────────────────────┼─────────────────────────────┤
│    Z (20) │                    I:1 (50) │                    I:0 (50) │ 144
├───────────┼─────────────────────────────┼─────────────────────────────┤
│ I:2L (20) │                    I:1 (50) │                    I:0 (50) │ 145
├─────┬─────┴─────────────────────────────┼─────────────────────────────┤
│   Z │                          I:0 (60) │                      T (50) │ 146
│ (10)│                                   │                             │
├─────┼───────────────────────────────────┼─────────────────────────────┤
│ I:1L│                          I:0 (60) │                      T (50) │ 147
│ (10)│                                   │                             │
├─────┼───────────────────────────────────┼─────────────────────────────┤
│   Z │                          I:1 (60) │                    I:0 (50) │ 148
│ (10)│                                   │                             │
├─────┼───────────────────────────────────┼─────────────────────────────┤
│ I:2L│                          I:1 (60) │                    I:0 (50) │ 149
│ (10)│                                   │                             │
├─────┴───────────┬─────────────────┬─────┴─────────────────────────────┤
│        I:2 (30) │        I:1 (30) │                          I:0 (60) │ 150
├─────────────────┼─────────────────┼───────────────────────────────────┤
│       I:2L (30) │        I:1 (30) │                          I:0 (60) │ 151
├───────────┬─────┴─────────────────┼───────────────────────────────────┤
│    Z (20) │              I:1 (40) │                          I:0 (60) │ 152
├───────────┼───────────────────────┼───────────────────────────────────┤
│ I:2L (20) │              I:1 (40) │                          I:0 (60) │ 153
├─────┬─────┴───────────────────────┼───────────────────────────────────┤
│   Z │                    I:1 (50) │                          I:0 (60) │ 154
│ (10)│                             │                                   │
├─────┼─────────────────────────────┼───────────────────────────────────┤
│ I:2L│                    I:1 (50) │                          I:0 (60) │ 155
│ (10)│                             │                                   │
├─────┴─────────────────────────────┼───────────────────────────────────┤
│                          I:1 (60) │                          I:0 (60) │ 156
└───────────────────────────────────┴───────────────────────────────────┘




──────────────────────
6.7  Vector Processing
──────────────────────


Aura features general-purpose vector processing capability in the base architecture. This capability is intended to serve applications that have tightly coupled scalar and vector processing (on 8-, 16-, 32-, and 64-bit elements) by permitting the GPR and RNR sets to contain both scalar and vector operands. The vector processing capability consists of instructions that operate on vector—vector and vector—scalar operands. More advanced vector processing capabilities must be provided by architecture extensions.




───────────────
Scalar Operands
───────────────


Scalar operands in vector instructions have a value that is constant. That is, for every iteration of the vector operation, the value of the scalar operands are the same. The scalar operands are consumed when they are read for the first iteration. Afterwards, their registers are no longer a part of the vector instruction, and can be reused by a subsequent instruction.




─────────────
The 'T' Field
─────────────


Some vector instructions contain a 2-bit 'T' field that specifies the vector type of the operands and result. The value of the 'T' field identifies the vector type. The values and their definitions are as follows:

• 2'B00: V2
• 2'B01: V4
• 2'B10: V8
• 2'B11: V16

Some vector instructions may define an alternative use, or additional uses, for the 'T' field.








─────────────────
7  Primary Memory
─────────────────


The primary memory is an abstract entity that provides all processors and agents in the computer system with a shared random-access memory (RAM). The primary memory can be read and written by all processors and agents in the computer system.

The abstraction of primary memory as a singular entity does not imply it must be physically homogeneous and monolithic, it may, as an example, be composed of multiple physically distributed and heterogeneous parts. Additionally, the term 'RAM' refers to the ability of a memory to address and access arbitrary locations efficiently. It does not imply the primary memory is realized by any specific technology.




───────────────────────────────
7.1  Addressing Characteristics
───────────────────────────────


The primary memory's contents are addressed with a 128-bit memory address. These are 128-bit unsigned integers whose value identifies a corresponding location. The two basic addressable units of memory are the 8-bit octet and 128-bit word. The sizes of the memory address and word combined permits the primary memory to have a maximum capacity of 2**135 bits (2**132 octets or 2**128 words).

The first location in the primary memory is identified by the value zero (128'D0). All memory addressing-related arithmetic is modular―when the 128-bit unsigned integer overflows, its value is the modulo of the true value and 2**128.

The primary memory is addressed with two 'addressing schemes': the 'octet addressing scheme' and the 'word addressing scheme'. These schemes are based around the respective basic addressable units; and differ in the type of location identified by a memory address, and range of memory a memory address can identify.




─────────────────────────────────
7.1.1  The Word Addressing Scheme
─────────────────────────────────


The word addressing scheme (word addressing) treats the primary memory as 2**128 locations, each containing a 128-bit word, called 'word locations'. The memory addresses for this scheme are called 'word addresses', and the maximally sized 128-bit word address permits any word to be addressed. Word-sized loads and stores permit every sub-word unit of data to be accessed indirectly via the use of an additional "index" for identifying the sub-word unit of data, and additional instructions to extract and deposit the identified sub-word unit of data.

Word addresses that are less than 2**124 in value have a corresponding octet address (see Section 7.1.2, The Octet Addressing Scheme); the product of the word address and 16. The word addresses at 2**124 through to (2**128) -1 (inclusive) do not have a corresponding octet address because there are only 2**128 octet addresses (see Section 7.1.2, The Octet Addressing Scheme).




──────────────────────────────────
7.1.2  The Octet Addressing Scheme
──────────────────────────────────


The octet addressing scheme (octet addressing) treats the primary memory as 2**132 locations, each containing an 8-bit octet, called 'octet locations'. The memory addresses for this scheme are called 'octet addresses', and the maximally sized 128-bit octet address permits any octet at locations 0 through to (2**128) - 1 (inclusive) to be addressed, but not those at locations 2**128 through to (2**132) - 1, inclusive.

Units of data that are larger than octets (bi-octets, quadrant-words, semi-words, and words) can also be addressed under this scheme. These units of data are laid out in the primary memory in little-endian order, and take the memory address (octet address) of the first octet in the unit of data. The octet address must be an integral multiple of 2 for bi-octets, 4 for quadrant-words, 8 for semi-words, and 16 for words. Octet addresses that meet these requirements are described as 'aligned'; those that are not, as 'unaligned'.

Attempting to reference the primary memory using unaligned octet addresses will fail―a precise exception (UNALIGNED PRIMARY MEMORY ADDRESS) is generated and no memory operation will be performed. This exception has a privilege level of 1 (Privileged).

The following diagram illustrates these requirements. The octet address is given as a base address plus an offset. Each of the five units of data are laid out in the memory as if they were elements in a linear array. Each element is identified by an integer prefixed by "#", and its octet address is given as an offset from the base address.


┌───────────┬───────────┬───────────┬───────────┬───────────┬───────────┐
│ Base      │ Octet     │ Bi-octet  │ Quadrant- │ Semi-word │ Word      │
│ Address   │           │           │ word      │           │           │
├───────────┼───────────┼───────────┼───────────┼───────────┼───────────┤
│ +0        │  #0 @ +0  │  #0 @ +0  │  #0 @ +0  │  #0 @ +0  │  #0 @ +0  │
├───────────┼───────────┤           │           │           │           │
│ +1        │  #1 @ +1  │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +2        │  #2 @ +2  │  #1 @ +2  │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +3        │  #3 @ +3  │           │           │           │           │
├───────────┼───────────┼───────────┼───────────┤           │           │
│ +4        │  #4 @ +4  │  #2 @ +4  │  #1 @ +4  │           │           │
├───────────┼───────────┤           │           │           │           │
│ +5        │  #5 @ +5  │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +6        │  #6 @ +6  │  #3 @ +6  │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +7        │  #7 @ +7  │           │           │           │           │
├───────────┼───────────┼───────────┼───────────┼───────────┤           │
│ +8        │  #8 @ +8  │  #4 @ +8  │  #2 @ +8  │  #1 @ +8  │           │
├───────────┼───────────┤           │           │           │           │
│ +9        │  #9 @ +9  │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +10       │ #10 @ +10 │  #5 @ +10 │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +11       │ #11 @ +11 │           │           │           │           │
├───────────┼───────────┼───────────┼───────────┤           │           │
│ +12       │ #12 @ +12 │  #6 @ +12 │  #3 @ +12 │           │           │
├───────────┼───────────┤           │           │           │           │
│ +13       │ #13 @ +13 │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +14       │ #14 @ +14 │  #7 @ +14 │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +15       │ #15 @ +15 │           │           │           │           │
├───────────┼───────────┼───────────┼───────────┼───────────┼───────────┤
│ +16       │ #16 @ +16 │  #8 @ +16 │  #4 @ +16 │  #2 @ +16 │  #1 @ +16 │
├───────────┼───────────┤           │           │           │           │
│ +17       │ #17 @ +17 │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +18       │ #18 @ +18 │  #9 @ +18 │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +19       │ #19 @ +19 │           │           │           │           │
├───────────┼───────────┼───────────┼───────────┤           │           │
│ +20       │ #20 @ +20 │ #10 @ +20 │  #5 @ +20 │           │           │
├───────────┼───────────┤           │           │           │           │
│ +21       │ #21 @ +21 │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +22       │ #22 @ +22 │ #11 @ +22 │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +23       │ #23 @ +23 │           │           │           │           │
├───────────┼───────────┼───────────┼───────────┼───────────┤           │
│ +24       │ #24 @ +24 │ #12 @ +24 │  #6 @ +24 │  #3 @ +24 │           │
├───────────┼───────────┤           │           │           │           │
│ +25       │ #25 @ +25 │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +26       │ #26 @ +26 │ #13 @ +26 │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +27       │ #27 @ +27 │           │           │           │           │
├───────────┼───────────┼───────────┼───────────┤           │           │
│ +28       │ #28 @ +28 │ #14 @ +28 │  #7 @ +28 │           │           │
├───────────┼───────────┤           │           │           │           │
│ +29       │ #29 @ +29 │           │           │           │           │
├───────────┼───────────┼───────────┤           │           │           │
│ +30       │ #30 @ +30 │ #15 @ +30 │           │           │           │
├───────────┼───────────┤           │           │           │           │
│ +31       │ #31 @ +31 │           │           │           │           │
└───────────┴───────────┴───────────┴───────────┴───────────┴───────────┘


Octet addresses that are multiples of 16 have a corresponding word address―the quotient of the octet address divided by 16.




─────────────────────────────────────
7.1.3  Instruction Package Addressing
─────────────────────────────────────


Processors fetching or prefetching instruction packages always use the word addressing scheme in order to be able to address every one of the 2**128 possible word locations. Software should preferably read and write instruction packages using only the word addressing scheme for the same reason, but software may use the octet-addressing scheme if it is not necessary to access the word locations at 2**124 through to (2**128) - 1, inclusive.




──────────────────────────────────────────────────
7.1.4  Conversion Between Octet and Word Addresses
──────────────────────────────────────────────────


Octet and word addresses are incompatible, but there are locations that can be addressed by both types of addresses. In these cases, one type of address can be converted into the other by software. After conversion, it may be possible to access those locations that are not addressable in the original type of address with additional instructions.

Octet addresses are converted into word addresses by dividing the octet address by 16. This can be easily accomplished by a right shift. Word addresses are converted into octet addresses by multiplying the word address by 16. This can be easily accomplished by a left shift.




───────────────────────────────────────
7.2  Support for Smaller Address Spaces
───────────────────────────────────────


Implementations may support a subset of the locations in the 128-bit address space. This is accomplished by having N-bit memory addresses, where 0 < N < 128. If N-bit memory addresses are utilized, then both octet and word addresses have the same size.

The octet and word locations in the 128-bit address space that cannot be identified by an N-bit memory address do not exist. M-bit memory addresses, where N < M ≤ 128, are converted into N-bit addresses by taking the modulo of its value and 2**N.

For convenience, the descriptions of instructions that compute memory addresses in The Aura Computer Architecture Part II are written as if the full 128-bit addresses are always computed.




────────────────────────────────
7.3  Read and Write Side Effects
────────────────────────────────


Reads and writes do not have any side effects. A side effect is any effect other than the effect or effects prescribed by the mechanism that caused the read or write.




──────────────────────────────────
7.4  Unbacked and Backed Locations
──────────────────────────────────


Every octet and word location in the primary memory address space exists. However, a word location is not required to be backed by the means for storing data, and it is possible for a word location to alternate between not being backed and being backed by the means for storing data over time (with one exception, see below).

A word location that is not backed by a means for storing data is referred to as an 'unbacked location', and one that is, as a 'backed location'. A word location is guaranteed to be either a backed or unbacked location. There cannot exist an intermediate condition where some of the bits in a word are backed, but the rest are not. Thus, octet locations that are mapped onto word locations inherit the property of being backed or unbacked. The same applies to those units of data that are larger than an octet, but smaller than a word.

The first word location in the primary memory must be a backed location. This requirement is because the initial value of the instruction package memory address register is zero, and control is transferred to an instruction in the instruction package stored at this word location when the computer system is started.

Reads of unbacked locations return an unpredictable value. Writes to such locations do not perform any action, and STORE ATOMIC instructions fail unconditionally.

The base architecture does not provide any mechanism for querying which word locations are backed or unbacked, or for notifying software when word locations have changed into the opposing status.

Implementations may define additional effects for accesses to unbacked locations. If additional effects are defined, they are not considered to be side effects, as defined by Section 7.3, Read and Write Side Effects.

Architecture extensions may define additional characteristics and effects for unbacked locations.

The architectural concept of backed and unbacked locations exists so that implementations may be designed, configured, and operated with a primary memory whose capacity is less than that supported by its implemented address space. This effort should not be construed as condoning the haphazard placement of unbacked locations throughout the word address space. Implementations and configurations are expected to treat this concept sensibly.




─────────────────────────────────────────────────
7.5  The Initial Value of Primary Memory Contents
─────────────────────────────────────────────────


The initial value of a backed location when the Aura computer system is started, and when a word location has changed from being an unbacked location to a backed location, is unpredictable from the perspective of the architecture. In order to realize practical implementations that are capable of running software, there must be deterministic behavior after the Aura computer system is started. This deterministic behavior is the effect of some non-architectural mechanism that "initializes" some of the primary memory's contents with "data" (actually instruction packages) from storage when the Aura computer system is started.








─────────
8  Agents
─────────


Agents are computer systems that perform tasks on the behalf of processors. Examples of such tasks include accelerating specialized workloads and providing input/output capability. Agents operate independently of, and concurrently with, other agents and processors in an Aura computer system.

Agents are abstract entities that do not imply any concrete mapping to physical entities. For example, it is possible for multiple agents to be implemented as a time-division multiplexed state machine, or as an equal number of dedicated programmable general-purpose computers.

Agents are heterogeneous with respect to processors. Each agent may have its own architecture, implementation, or both; thus, agents may be heterogeneous to other agents by any degree. The architecture and implementation of agents is mostly outside the scope of the Aura computer architecture. Aura merely requires the architectures of agents to have certain characteristics in order to inter-operate with processors and the primary memory.

Agents are identified and addressed by a 128-bit agent address. Agents can support a subset of the 128-bit agent address space by limiting the size of the agent address to N bits, where 0 < N < 128.

Agents address processors using a 128-bit processor address. Agents may support a subset of the 128-bit processor address space by limiting the size of the processor address to N bits, where 0 < N < 128.

Agents must be able to send and receive interrupts to and from processors. Additionally, agents can optionally send and receive interrupts to and from other agents. Interrupts sent by an agent to a processor or another agent are unordered, but cannot be speculative. The interrupts received by a processor or agent do not have to be in the same order in which they were sent. An agent may have mechanisms to enforce interrupt ordering.

Agents must be able to access the primary memory in the same manner as processors. Which types of memory accesses are supported depends on the functionality provided by the agent. For example, an agent may only support reads if its functionality does not require writes.

Agents are not required to support the entire primary memory address space. If an agent supports a subset of the primary memory address space, it follows the standard primary memory address space sub-setting rules.








────────────────────────────────────
9  The Aura Memory Consistency Model
────────────────────────────────────


The Aura Memory Consistency Model (AMCM) is a set of rules that define which values a read of the primary memory may return. The AMCM is a weak memory consistency model (MCM). It has few implicitly enforced orderings between memory accesses, which enables efficient, high-performance implementations. The majority of enforced orderings must be explicitly stated.

For processors, software explicitly states which orderings are enforced by inserting appropriately specified Memory Barrier instructions into the static instruction stream where necessary. For agents, the equivalent is accomplished by an agent-defined mechanism that is equivalent or similar to the functionality of the Memory Barrier instruction.

Processors and agents may implement an MCM that is stronger than the AMCM if its weak nature is undesirable. This stronger MCM must be compatible with all processors and agents in the computer system.

NOTE: This description of the AMCM should be treated as a rough outline of intent, not as a precise definition. As of this document version, the AMCM has not been formally defined, analyzed, or verified.




────────────────────
9.1  Characteristics
────────────────────


The AMCM conceptualizes the primary memory as consisting of 2**128 words. References using octet addresses and references to sub-word units of data are treated by the AMCM as if they are using word addresses and references to words. This is accomplished by converting octet addresses into word addresses (if they are used to reference words); otherwise, by aliasing octet addresses that reference sub-word units of data into the word addresses of the words the sub-word units of data reside in, and "promoting" the sub-word accesses into word accesses.




───────────────────────────────────────────────────────
The Definition of 'Program Order' and 'Operation Order'
───────────────────────────────────────────────────────


The AMCM pertains to memory accesses (reads and writes) and memory ordering mechanisms. The cause of these events (an instruction in a program, or a hardware state machine) is irrelevant. The order in which events are initiated is related to the order of the mechanisms that initiate them.

For processors, this order is the 'program order', which is the order in which events are relevant instructions (such as those that initiate memory accesses) appear in a processor's dynamic instruction stream.

The equivalent of this concept for agents is called the 'operation order', since agents are not required to be stored-program computers, and may be, for example, hardware-based state machines. The operation order is the order in which relevant events (such as those that initiate memory accesses) appear in an agent's operation sequence.




──────────────────
Implicit Orderings
──────────────────


The AMCM enforces the following memory accesses and memory ordering mechanisms:

• A read or write precedes a memory ordering mechanism in program or operation order.
• A memory ordering mechanism precedes a read or write in program or operation order.
• A memory ordering mechanism precedes another memory ordering mechanism in program or operation order.

• A read precedes a write in program or operation order, if their addresses are identical.
• A write precedes a read in program or operation order, if their addresses are identical. This ordering is enforced only on the processor or agent that initiated the write and read, not between writes and reads from different processors or agents.
• A write precedes another write in program or operation order, if their addresses are identical.

The instructions in a processor's dynamic instruction stream or the events in an agent's event sequence may be related by dependences. Some of these dependences have implications for memory ordering. There are three types of dependences:

• Address dependence: A read value is consumed to produced the memory address for a memory access.
• Control dependence: A read value is consumed by a control flow instruction or an equivalent mechanism that decides whether a memory access is initiated or not.
• Data dependence: A read value is consumed by a write as the write value.

These dependencies may be direct or indirect; in the former case, the read value is immediately consumed by the memory access, whereas in the latter case, the read value may undergo processing by any number of intermediate instructions or operations before being consumed.

The existence of any dependence between a read and a write that succeeds the read in program or operation order causes them to be ordered as they are in the program or operation order.




─────────────────────────────
The Definition of 'Performed'
─────────────────────────────


Reads and writes by a given processor or agent are 'performed' with respect to other processors and agents.




──────────────
Write Progress
──────────────


Writes from a given processor or agent must be performed with respect to all other processors and agents after a finite amount of time.




───────────────────
Write Serialization
───────────────────


Writes to the same primary memory location by any processor or agent are serialized. The order in which the writes are serialized is unpredictable.




───────────────
Write Atomicity
───────────────


The AMCM is not multi-copy write atomic. Writes from a given processor or agent are propagated to all other processors and agents at different times, different orders, or both. A given processor or agent (including the processor or agent from which the write originated from) may read from a write that has not propagated to all processors and agents.




───────────────────────────────────────────
Memory Ordering Mechanisms and Cumulativity
───────────────────────────────────────────


The MEMORY BARRIER instruction and the equivalent mechanism in agents are 'cumulative'. This property is defined as follows:

• A given processor or agent (P1 or A1), uses a memory ordering mechanism (M).
• The memory accesses from P1 or A1 that precede M in program order or the equivalent concept in agents are members of set P.
• All memory accesses from all other processors and agents that have been performed with respect to P1 or A1 before M was used are also members of set P.
• The memory accesses from P1 or A1 that succeed M in program order or the equivalent concept in agents are members of set S.
• All memory accesses from all other processors and agents that are ordered after M, by implicit orderings or explicit memory ordering mechanisms, are also members of set S.




─────────────────────────────────────────────────
9.2  Instructions Requiring Special Consideration
─────────────────────────────────────────────────


Some instructions in the architecture have characteristics that require special consideration by the AMCM. These instructions are documented here. Agents access the primary memory in the same or similar manner as processors. If an agent has an architecture or organization (since agents may be non-programmable) that replicates or is similar in functionality to any of the instructions here, it must take the same special considerations.




──────────────────────────────────────────
Octet-Addressed Memory Access Instructions
──────────────────────────────────────────

Octet-addressed memory access instructions generate UNALIGNED PRIMARY MEMORY ADDRESS exceptions (see Section 7.1, Addressing Characteristics). If this exception is generated by an instruction, the memory operation is not initiated, and consequently, the instruction is invisible to the AMCM.




────────────────────────────────────────
Store Atomic Instructions and Operations
────────────────────────────────────────


Store Atomic instructions that do not write to the primary memory (because they did not meet the necessary conditions) do not initiate a write. Store Atomic instructions that do not initiate a write are consequently invisible to the AMCM.








───────────────────────────
10  Architecture Extensions
───────────────────────────


Aura is designed to be extended by architecture extensions (AEs). These can extend the base architecture in any manner, but cannot redefine existing features in the base architecture (redefining the base architecture is exclusive to new versions).

For example, adding support for virtual memory to the base architecture is permitted because it does not contradict the base architecture (which does not have any concept of virtual and physical addresses); the virtual-to-physical address translation that is performed is invisible to the base architecture, and the architectural state and instructions added are clearly extensions to the base architecture.




───────────────────────────────
10.1  Identification Mechanisms
───────────────────────────────


Aura has an architectural mechanism for providing AEs with an identity. This enables Aura to provide an instruction that queries if an AE is supported by a processor (see Part II, Section 2, Architecture Version and Extension Instructions). While AEs may have implications for agents, Aura does not have a similar mechanism for agents, as they are either hardware-based state machines or implementations of agent-specific architectures.

AEs are identified by Architecture Extension Identifiers (AEIs) in combination with Architecture Extension Namespaces (AENs). There are 2**64 AENs, which are assigned to AE creators; and each AEN contains 2**64 AEIs, which are assigned to AEs. The number of AENs and AEIs permits them to be expressed as 64-bit unsigned integers.

Aura uses a two-stage mechanism to identify AEs in order to provide AE creators with autonomy. By delegating AEI assignments within an AEN to its holder, AEs do not have to be assigned from a global pool of identifiers managed by Aura's architects. AENs disambiguate AEs from different creators with identical AEIs by providing information that identifies the creator.

AENs are assigned to AE creators by Aura's architect upon request. Each AE creator may only receive one AEN. AEN assignments are usually permanent, but the assignment can be updated upon request if warranted; unwarranted requests are rejected. Assigned AENs can be retired by Aura's architect if it is deemed necessary. One natural use of this prerogative is if an assigned AEN becomes abandoned. The AEIs in retired AENs cannot be assigned to new AEs.

An AEN holder may obtain multiple AENs by subsuming other AEN holders. The AENs assigned to the subsumed holder are reassigned to the subsuming holder. The subsuming holder may use the subsumed AENs for any purpose, but the subsuming holder is expected to continued the established usage mode of the subsumed AENs (unless it decides to discontinue their continued usage).

It is important to note that obtaining multiple AENs by setting up AEN holders to subsume at a later time is an abuse of the identification mechanisms. AEN holders that perpetrate such activity will have all their AENs retired.

AENs are assigned in sequential order starting from AEN 1. Unassigned AENs are reserved for future use. The base architecture contains the following preassigned AENs:

• AEN 0: Reserved
• AEN 1: Aura
• AEN 2: Marius Dahl

AEN 0 is reserved for internal use by the public. Because AEN 0 is not managed by a single entity, one entity's usage of this AEN's AEIs are expected to conflict with those made by another. Thus, AEs inside AEN 0 are not externally identifiable. The purpose of AEN 0 is to provide an AEN for development and experimentation without requiring an AEN to be obtained.

AEN 1 is assigned to the Aura computer architecture. It contains standard AEs that provide features that should remain optional and outside the base architecture. Since AEN 0 contains standard AEs, some AEs might use primary operation code values that are reserved by the base architecture for future use.

AEN 2 is assigned to Marius Dahl.

All other AEN assignments are documented separately.

AEIs inside an AEN are assigned to AEs by the AEN's holder at their discretion subject to the following restrictions: AEIs are assigned in sequential order starting from AEI 0; AEI assignments are permanent. AEN holders are responsible for documenting AEI assignments inside their AENs, and for, optionally, publishing their AEI assignments.




─────────────────────────────────
10.2  Instruction Encoding Issues
─────────────────────────────────


Every instruction format across all instruction sizes have a 3-bit primary operation code field in bits 0—2. In 30- and 40-bit instructions, three primary operation codes (5—7) are reserved for use by AEs in AENs greater than AEN 0; in 50- and 60-bit instructions, four primary operation codes (4—7) are reserved. AEs generally cannot use any other primary operation codes.

AEs are not required to be free of instruction encoding conflicts. It is the responsibility of the implementer to ensure that they do not implement AEs with conflicting instruction encodings.

Future versions of Aura may reuse instruction encodings used by some AEs for other purposes. If this occurs, those AEs must be reported as unsupported by the implementations of the future version of Aura.




──────────────────────────────────────────
10.3  Promotion of Architecture Extensions
──────────────────────────────────────────


An AE can be promoted into the base architecture in a future version of Aura, after which the AE's features become mandatory parts of the base architecture. If the AEN of the AE is AEN 0, promotion is straightforward. Versions featuring the promoted AE always report the AEI of the AE as supported, even though the AE is now a part of the base architecture, and is no longer an optional AE.

If the AEN of the AE is not AEN 0, promotion requires all the instructions defined by the AE to be re-encoded so that their primary operation codes lie within the appropriate range for the instruction size.

The original instruction encoding of AE may be supported by the implementation. If this is the case, the AEI of the AE is reported by supported. If this is not the case, then binary compatibility is lost, and the AEI of promoted AE must be reported as unsupported.

The ability to have two instruction encodings of a promoted AE is intended to give time to software to migrate from the older encoding to the newer. This allows the encoding space used by the older encoding to be reused at a later time.








─────────────────────────────────────
11  Derivative Computer Architectures
─────────────────────────────────────


Aura is an open computer architecture from which new architectures can be derived (or forked). Derivatives of Aura are by definition, not Aura. Thus, if any Aura versioning and architecture extension identification features are retained, these are reset: no assigned Architecture Version Identifiers, Architecture Extension Namespaces, and Architecture Extension Identifiers are carried over to the derived architecture.








────────────────────────
12  Miscellaneous Topics
────────────────────────




─────────────────
Naming Background
─────────────────


Aura takes its name from the Classical Latin word for 'breeze'. To distinguish it from English, Aura should be pronounced as it is in Classical Latin, and it may be written in the Classical Latin convention (as 'AVRA').




───────────────────
Development History
───────────────────


Work on Aura began in April 2019. The first publicly released version (a draft for Aura Version 1.0, dated 2020-07-31) was made available in August 2020.
